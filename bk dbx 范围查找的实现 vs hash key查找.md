bk dbx 范围查找的实现 vs hash key查找

<!-- TOC -->

- [scan all](#scan-all)
- [有序列表 zset 比较简单](#有序列表-zset-比较简单)
- [btree实现比较复杂](#btree实现比较复杂)
- [可以把折半查找看作二叉树查找法。。](#可以把折半查找看作二叉树查找法)
- [简化索引 数据自带索引模式](#简化索引-数据自带索引模式)
- [让数据自带索引  id编码规则 这样就不需要索引了。](#让数据自带索引--id编码规则-这样就不需要索引了)
- [uid的改进  url模式](#uid的改进--url模式)

<!-- /TOC -->


范围查询的原理  wehre a>444 and a<444

first postiston to 444 idx,,then 顺序读取。。
如何查找到444，二分查找法 vs tree查找
如果表有一个亿   。。3次才能这反到千万级别。。百万级别又是3次。
十万级别3次。。1万级别又3次。。。1千次。。

5kw,2500w,1200w,600w,300w,150w,80w,40w,20w,10w,5w,3w,1w,5k,2000   ...差不多需要15次才能定位到

那么找到444一共需要io次数 15次。。不是很多。。
如果btee，闪出10000*10000的话，貌似只需要3次。。

# scan all
# 有序列表 zset 比较简单
使用有序列表实现比较简单。。zset rds

# btree实现比较复杂
使用btree实现比较复杂了。可以利用embd db sqlt来做btree idx

# 可以把折半查找看作二叉树查找法。。
每次一分为二

那么如何扇出呢 增加。。可以使用三分，四分查找法嘛。。五分查找法。。  十进制十分查找法也不错。。。相当于btree的实现了。。



如何查找到444，10分查找法  
如果表有一个亿，索引等分为10份，分别比较其范围。。以此类推。。。
5次读取就可以确定到千万，5次到百万，5次十万，5次到一万，5次到一千。。总共  25次？？

二分查找树虽然是一个天然的二分结构，能很好的利用二分查找快速定位数据，但是它存在一种极端的情况，每当插入的元素都是树内最大的元素，就会导致二分查找树退化成一个链表，此时查询复杂度就会从 O(logn)降低为 O(n)。

为了解决二分查找树退化成链表的问题，就出现了自平衡二叉树，保证了查询操作的时间复杂度就会一直维持在 O(logn) 。但是它本质上还是一个二叉树，每个节点只能有 2 个子节点，随着元素的增多，树的高度会越来越高。


二分查找
二分查找是最基本的，后面的二叉树，平衡二叉树，B树，B+树都是基于二分查找演变而来的。

二分查找法作为一种常见的查找方法，将原本是线性时间提升到了对数时间范围，大大缩短了搜索时间，但它有一个前提，就是必须在有序数据中进行查找

# 简化索引 数据自带索引模式
# 让数据自带索引  id编码规则 这样就不需要索引了。


A1003-10-17），找到保险柜所在 A1003的存放房间，找到存放室保险柜的第10排，再找到第17个位置，找到属于你的保险柜，这个定位就快很多了

# uid的改进  url模式

自增id_uuid_存储位置索引（Nodeid_db_tabl)

orNodeid（ip_port) 

uuid可以防重复，并且防止猜测，安全