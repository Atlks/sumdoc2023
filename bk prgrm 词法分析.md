bk prgrm 词法分析


<!-- TOC -->

- [词法分析](#词法分析)
    - [双case分析法](#双case分析法)
    - [扫描器](#扫描器)
    - [token 生成器](#token-生成器)
    - [评估器（Evaluator）。将记号进行分类](#评估器evaluator将记号进行分类)
    - [正则表达式搜索split](#正则表达式搜索split)
    - [使用普通的splt模式来实现，比如url这样一类](#使用普通的splt模式来实现比如url这样一类)
    - [7.2 直接扫描法](#72-直接扫描法)
- [直接扫描法](#直接扫描法)
- [正则表达式匹配的分词扫描法](#正则表达式匹配的分词扫描法)
- [字典匹配的分词扫描发](#字典匹配的分词扫描发)

<!-- /TOC -->


# 词法分析

## 双case分析法
递归下降法

分词器 字典模式法

fsm有限状态自动机

最长一致原则
很多情况下，根据第一个非空白字符便可以推导出该记号的类型，于是便可逐个处理之后的字符，直到出现不属于该类型记号字符集中的字符（即最长一致原则）。



记号化（tokenization）即将输入字符串分割为记号、进而将记号进行分类的过程。生成的记号随后便被用来进行语法分析。

例如对于如下字符串： 
The quick brown fox jumps over the lazy dog

计算机并不知道这是以空格分隔的九个英语单词，只知道这是普通的43个字符构成的字符串。可以通过一定的方法（这里即使用空格作为分隔符）将语素（这里即英语单词）从输入字符串中分割出来。



## 扫描器
编辑
词法分析的第一阶段即扫描器，通常基于有限状态自动机。扫描器能够识别其所能处理的记号中可能包含的所有字符序列（单个这样的字符序列即前面所说的“语素”）


## token 生成器
编辑
记号化（tokenization）即将输入字符串分割为记号、进而将记号进行分类的过程。生成的记号随后便被用来进行语法分析。
然而，语素只是一类字符构成的字符串（字符序列），要构建记号，语法分析器需要第二阶段的

## 评估器（Evaluator）。将记号进行分类
评估器根据语素中的字符序列生成一个“值”，这个“值”和语素的类型便构成了可以送入语法分析器的记号。一些诸如括号的语素并没有“值”，评估器函数便可以什么都不返回。整数、标识符、字符串的评估器则要复杂的多。评估器有时会抑制语素，被抑制的语素（例如空白语素和注释语素）随后不会被送入语法分析器。

尽管在某些情况下需要手工编写词法分析器，一般情况下词法分析器都用自动化工具生成。


简单正则法生成词法分析
使用字典法生成token列表 评估分类器

## 正则表达式搜索split

因为字符串可能包含双引号和空格，所以使用普通的空格splt就有问题了额。。需要使用regexprs来分割。。

## 使用普通的splt模式来实现，比如url这样一类
但这样要求没有特殊符号，需要转义
方便解析这样。。
转义的模式俩种，一种url模式%xx 更好解析
一种使用反斜杠转义，比较麻烦些，但可使用正则识别。。



## 7.2 直接扫描法
直接扫描法的思路非常简单，每轮扫描，根据第一个字符判断属于哪种类型的 token ，然后采取不同的策略扫描出一个完整的 token ，再接着进行下一轮扫描。例如 TinyC 中，若仅考虑一些简单的情况，按 token 的第一个字符，可以将所有类别的 token 分为以下 7 大类：

（1）A型单字符运算符

包括：+, -, *, /, %， 这种 token 只有一个字符，若本轮扫描的第一个字符为上述字符，则立即返回此字符所代表的 token ，然后移到下一个字符开始下一轮扫描。

（2）B型单字符运算符和双字符运算符

B型单字符运算符包括： < > = ! ，双字符运算符包括： <=, >=, ==, != 。 若本轮扫描的第一个字符为B型单字符运算符时，先查看下一个字符是否是 “=” ，如果是，则返回这两个字符代表的 token ，如果否，则返回这个字符代表的 token 。例如，如果扫描到 “>” ，则查看下一个字符是否是 “=” ，是则返回 T_GREATEEQUAL ，否则返回 T_GREATTHAN 。

（3）关键词和标识符

关键词和标识符都是以字母或下划线开始、且只有字母、下划线或数字组成。若本轮扫描的第一个字符为字母或下划线时，则一直向后扫描，直到遇到第一个既不是字母、也不是下划线或数字的字符，此时一个完整的词就被扫描出来了，然后，查看这个词是不是为关键字，如果是，则返回关键字代表的 token ，如果不是，则返回 T_IDENTIFIER 以及这个词的字面值。

（4）整数常量

整数常量以数字开始，若本轮扫描的第一个字符为数字，则一直向后扫描，直到遇到第一个非数字字符，然后返回 T_INTEGERCONSTANT 和这个数字。

（5）字符串常量

字符串常量以双引号开始和结束，若本轮扫描的第一个字符为双引号，则一直向后扫描，直到遇到第一个双引号，然后返回 T_STRINGCONSTANT 和这个字符串。

# 直接扫描法
以看出直接扫描法思路简单，代码量非常少，scan.py 不过 100 代码。但缺点是速度慢，对标识符类型的 token 需要进行至少 2 次扫描，且需进行字符串查找和比较。而且不容易扩展，只适用于语法简单的语言。目前一般的编译器都是采用基于正则表达式匹配的分词扫描法

for()




# 正则表达式匹配的分词扫描法

可以看出有限状态自动机的判断速度是非常快的，它只要求对字符串扫描一遍就可以了，显然比前面介绍的直接扫描法要快多了。

总而言之，正则表达式的匹配判断可以通过构造有限状态自动机来进行，以上仅介绍了构造有限状态自动机的大体思路：先构造基本的自动机，再根据正则表达式的结构搭建出复杂的自动机。构造有限状态自动机的具体算法十分复杂

# 字典匹配的分词扫描发