bk dsn ha高可用 主从镜像 vs 备用模式

<!-- TOC -->

- [cloud svr  ,sever less ,,oss svr..](#cloud-svr--sever-less-oss-svr)
- [简单设计 简单即使可靠](#简单设计-简单即使可靠)
- [状态组件分离出去](#状态组件分离出去)
- [-------------other](#-------------other)
- [）存储高可用 file vs embddb  vs rds vs mgdb](#存储高可用-file-vs-embddb--vs-rds-vs-mgdb)
- [尽可能不要枷锁，使用mvcc机制版本比对](#尽可能不要枷锁使用mvcc机制版本比对)
- [冗余db分表模式 多用户隔离，业务库隔离，越多越好锁定减少了。](#冗余db分表模式-多用户隔离业务库隔离越多越好锁定减少了)
- [web nginx负载均衡即可](#web-nginx负载均衡即可)
- [微服务冗余](#微服务冗余)
- [镜像](#镜像)
- [定时健康监控巡检自动化](#定时健康监控巡检自动化)
- [模块 热插拔](#模块-热插拔)
- [尽可能分布式 无状态  cookie token模式](#尽可能分布式-无状态--cookie-token模式)
- [自动主备切换 哨兵fun](#自动主备切换-哨兵fun)

<!-- /TOC -->

# cloud svr  ,sever less ,,oss svr..
# 简单设计 简单即使可靠
# 状态组件分离出去 

# -------------other

# ）存储高可用 file vs embddb  vs rds vs mgdb
本地更加可用，防止单机网络故障

# 尽可能不要枷锁，使用mvcc机制版本比对
# 冗余db分表模式 多用户隔离，业务库隔离，越多越好锁定减少了。

# web nginx负载均衡即可

# 微服务冗余

# 镜像
对计算机比较了解的同学都知道磁盘的RAID模式，RAID提供了数据冗余来保证数据安全。当然RAID是服务器上的必备要求，但你知道吗，内存也有同样的模式，那就是内存镜像（Memory Mirror）。内存镜像将4个通道的内存成对存储相同的数据，类似磁盘的RAID 1，内存的数据在硬件上就被保存了两份，当一份损坏时还有备份，而更妙的是这些是对软件透明的。

这个冗余度和RAID1一样是很大的，一半的资源在大部分情况下闲置了，在提高可靠性的同时浪费也十分严重，有没有稍微省钱点的做法呢？当然有，那就是内存备用(Memory Sparing)，简单来说就是保留了部分内存，当出错再把这些内存拿来顶上。它的颗粒度可以到DIMM甚至以Rank为单位。

# 定时健康监控巡检自动化

# 模块 热插拔

# 尽可能分布式 无状态  cookie token模式

# 自动主备切换 哨兵fun


ived的配置文件可知，mysql关闭的话，将会执行keepalived_check_mysql.sh这一脚本。这个脚本在执行的时候，会判断mysql的状态，如果mysql关闭了，将会关闭keepalived进程，将mysqld的服务切换到从数据库。而后主数据修复，需手动切换到主数据库，再重启keepalived服务。Keepalived和nagios配合使用才能提供更好的服务。
 

那就要把底层的缓存搞好，让更少的请求直接到数据库，因为数据库的高并发实现起来是比较麻烦的，而且有些操作还有事务的要求等等，所以很难做到非常高的并发。
