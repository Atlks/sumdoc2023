微服务


从单体到微服务到 Function
在过去几年间，微服务架构成为业界主流，很多公司开始采用微服务，并迁移原有的单体应用迁移到微服务架构。从架构上，微服务和单体最大的变化在于微服务架构下应用的粒度被“拆小”：将所有业务逻辑都在一起的单体应用，按照领域模型拆分为多个内聚而自治的“更小”的应用。而 Function 则在拆分上更进一步，拆分粒度变成了“单个操作”，基于 Function 逐渐演进出现 FaaS 形态和 Serverless 架构。
对于 Function，这个问题就更加明显了：Function 的粒度更小，更专注业务逻辑。某些简短的 Function 可能只有几百行代码，但是，为了让这几百行代码运转起来而需要引入的共享类库和网络客户端可能相比之下就规模惊人


在采用 Function 时，如果依然沿用上面的方式，以单体或微服务架构的思维方式和设计模式来创建 FaaS/Serverless 架构： 不过是将微服务变成粒度更小的函数，导致系统中的远程调用数量大为增

只是把将组件的粒度从 “微服务“换成了 “Function/函数”。



引入 Event：解除不必要的强耦合
在解决了微服务/ Serverless 系统和外部分布式能力之间紧耦合的问题之后，我们继续看微服务/Serverless 系统内部紧耦合的问题。前面讨论到，从单体到微服务到 Function/Serverless，如果只是简单的将直接方法调用替换为远程调用（REST 或者 RPC），那么两个通讯的模块之间会因为这个紧密耦合的调用而形成依赖，而且依赖关系会伴随调用链继续传递，导致形成一个树形的依赖关系网络，表现为系统间的高度耦合：


Event 可以解耦生产者和消费者，因此图中的微服务 A 和微服务 C/D/E 之间没有强烈的依赖关系，彼此无需锁定对方的存在。但是 Command 不同，在采用 Command 方式后微服务 A 和下游相关微服务 C/D/E 会形成强依赖，而且这种依赖关系会蔓延，最终导致形成一颗巨大而深层次的依赖树，而 Function 由于粒度更细，问题往往更严重：

全程 Event 带来的问题：开发困难和业务边界不清晰
在 Command 和 Event 的使用上，除了全程使用 Command 之外，还有一个极端是全程使用 Event，这一点在 Lambda（FaaS）中更常见一些：、、、、、


# 微服务 团队规模 5-10个比较好
新的服务会进行更深思熟虑的规划。这些服务并不仅仅只做一件事：它们服务于一项业务功能。它们是由一个团队（5~10 名工程师）构建并维护的

# fun函数化微服务粒度最低比较好。。
单独的log db等。。lan lib


